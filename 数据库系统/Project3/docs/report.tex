% !Tex Program = xelatex
% -*-coding: utf-8 -*-
\documentclass[12pt,onecolumn]{report}

% 中文
\usepackage[BoldFont,SlantFont]{xeCJK}
\xeCJKsetemboldenfactor{1}%只对随后定义的CJK字体有效
\setCJKfamilyfont{hei}{SimHei}
\xeCJKsetemboldenfactor{4}
\setCJKfamilyfont{song}{SimSun}
\xeCJKsetemboldenfactor{4}
\setCJKfamilyfont{fs}{FangSong}
\setCJKfamilyfont{kai}{KaiTi}
\setCJKfamilyfont{li}{LiSu}
\setCJKfamilyfont{xw}{STXinwei}
\setCJKmainfont[BoldFont=SimHei]{SimSun}
\setCJKmonofont{SimSun}
\setCJKsansfont{SimSun}

\newcommand{\hei}{\CJKfamily{hei}}      % 黑体
\newcommand{\song}{\CJKfamily{song}}    % 宋体   (Windows 自带simsun.ttf)
\newcommand{\fs}{\CJKfamily{fs}}        % 仿宋体 (Windows 自带simfs.ttf)
\newcommand{\kai}{\CJKfamily{kai}}      % 楷体   (Windows 自带simkai.ttf)
\newcommand{\li}{\CJKfamily{li}}        % 隶书   (Windows自带simli.ttf)
\newcommand{\xw}{\CJKfamily{xw}}        % 隶书   (Windows自带simli.ttf)

% \AmSTeX\ 宏包，用来排出更加漂亮的公式。
\usepackage{amsmath}
% 定理类环境宏包，其中 \pkg{amsmath} 选项用来兼容 \AmSTeX\ 的宏包
\usepackage[amsmath,thmmarks,hyperref]{ntheorem}
\usepackage{amssymb}
% 添加字体
\usepackage[defaultsups]{newtxtext}
\usepackage{newtxmath}
\usepackage{courier}
% 图形支持宏包
\usepackage{graphicx}
% 插入pdf
\usepackage{pdfpages}
\includepdfset{fitpaper=true}
% 更好的列表环境。
\usepackage{enumitem}       %使用enumitem宏包,改变列表项的格式
\usepackage{environ}
% 禁止 \LaTeX 自动调整多余的页面底部空白，并保持脚注仍然在底部。
% 脚注按页编号。
\usepackage[bottom,perpage,hang]{footmisc}
\raggedbottom{}
% 脚注格式。
\usepackage{pifont}
% 表格控制
\usepackage{longtable}
\usepackage{booktabs}
% 参考文献引用宏包
\usepackage[sort&compress,numbers]{natbib}
% 生成有书签的 pdf 及其开关，请结合 gbk2uni 避免书签乱码。
\usepackage{hyperref}
\hypersetup{
  CJKbookmarks=true,
  linktoc=all,
  bookmarksnumbered=true,
  bookmarksopen=true,
  bookmarksopenlevel=1,
  breaklinks=true,
  colorlinks=false,
  plainpages=false,
  pdfborder=0 0 0}
% 设置 url 样式，与上下文一致
\urlstyle{same}
% 版芯设置
\usepackage{geometry}
\geometry{
  a4paper,
  centering,
  text={150true mm,236true mm},
  left=30true mm,
  head=5true mm,
  headsep=2true mm,
  footskip=0true mm,
  foot=5.2true mm
}
% 利用 \pkg{fancyhdr} 设置页眉页脚。
\usepackage{fancyhdr}
% 其他包，表格、数学符号包
\usepackage{tabularx}
\usepackage{varwidth}
% 此处changepage环境用来控制索引页面的左右边距，规范中给出的示例的边距要大于正文。
\usepackage{changepage}
% 多栏结构在文中用begin{multicols}{2}end{multicols}
\usepackage{multicol,multienum}
% 允许上一个section的浮动图形出现在下一个section的开始部分,还提供\FloatBarrier命
% 令,使所有未处理的浮动图形立即被处理
\usepackage[below]{placeins}
% 支持子图 %centerlast 设置最后一行是否居中
\usepackage{subfigure}
% 支持双语标题
\usepackage[subfigure]{ccaption}
% 根据我工规定，正文小四号 (12bp) 字，行距为固定值3--4mm。
\renewcommand\normalsize{
  \abovedisplayskip=8pt
  \abovedisplayshortskip=8pt
  \belowdisplayskip=\abovedisplayskip{}
  \belowdisplayshortskip=\abovedisplayshortskip}
% 根据习惯定义字号。用法：\cs{hit@def@fontsize}\marg{字号名称}\marg{磅数}避免了
% 字号选择和行距的紧耦合。所有字号定义时为单倍行距，并提供选项指定行距倍数。
\def\hit@def@fontsize#1#2{%
  \expandafter\newcommand\csname #1\endcsname[1][1.3]{%
    \fontsize{#2}{##1\dimexpr #2}\selectfont}}
\hit@def@fontsize{dachu}{58bp}
\hit@def@fontsize{chuhao}{42bp}
\hit@def@fontsize{xiaochu}{36bp}
\hit@def@fontsize{yihao}{26bp}
\hit@def@fontsize{xiaoyi}{24bp}
\hit@def@fontsize{erhao}{22bp}
\hit@def@fontsize{xiaoer}{18bp}
\hit@def@fontsize{sanhao}{16bp}
\hit@def@fontsize{xiaosan}{15bp}
\hit@def@fontsize{sihao}{14bp}
\hit@def@fontsize{banxiaosi}{13bp}
\hit@def@fontsize{xiaosi}{12bp}
\hit@def@fontsize{dawu}{11bp}
\hit@def@fontsize{wuhao}{10.5bp}
\hit@def@fontsize{xiaowu}{9bp}
\hit@def@fontsize{liuhao}{7.5bp}
\hit@def@fontsize{xiaoliu}{6.5bp}
\hit@def@fontsize{qihao}{5.5bp}
\hit@def@fontsize{bahao}{5bp}
% 利用 \pkg{enumitem} 命令调整默认列表环境间的距离，以符合中文习惯。
\setlist{nosep}
% 允许太长的公式断行、分页等。
\allowdisplaybreaks[4]
\predisplaypenalty=0  %公式之前可以换页，公式出现在页面顶部
\postdisplaypenalty=0
% 公式编号设置
\renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
% 定理标题使用黑体，正文使用宋体，冒号隔开。
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\hei}
\theoremsymbol{\ensuremath{\square}}
\newtheorem*{proof}{证明}
\theoremstyle{plain}
\theoremsymbol{}
\theoremseparator{}
\newtheorem{assumption}{假设}[chapter]
\newtheorem{definition}{定义}[chapter]
\newtheorem{proposition}{命题}[chapter]
\newtheorem{lemma}{引理}[chapter]
\newtheorem{theorem}{定理}[chapter]
\newtheorem{axiom}{公理}[chapter]
\newtheorem{corollary}{推论}[chapter]
\newtheorem{exercise}{练习}[chapter]
\newtheorem{example}{例}[chapter]
\newtheorem{remark}{注释}[chapter]
\newtheorem{problem}{问题}[chapter]
\newtheorem{conjecture}{猜想}[chapter]
% 各种单位
\usepackage{siunitx}
\sisetup{group-minimum-digits=4, group-separator= \hspace{0.25em}}
\sisetup{detect-weight,detect-mode,detect-family}
% 处理数学公式中的黑斜体的宏包
\usepackage{bm}
% 不同于 \mathcal \mathfrak 之类的英文花体字体
\usepackage{mathrsfs}
% 支持彩色
\usepackage[table]{xcolor}
\definecolor{colorzero}{rgb}{0, 0, 0}
\definecolor{colorone}{rgb}{1, 0, 0}
\definecolor{colortwo}{rgb}{0, 0, 1}
\definecolor{colorthree}{rgb}{0, 1, 0}
% 图形和表格的控制旋转
\usepackage{rotating}
% 算法的宏包，注意宏包兼容性，先后顺序为float、hyperref、algorithm(2e)，否则无法
% 生成算法列表。
\usepackage[algoruled,linesnumbered]{algorithm2e}
% 排版源码所使用的环境。
\usepackage{listings}
\lstset{
  language    = c++,
  breaklines  = true,
  frame       = single,
  captionpos  = b,
  tabsize     = 2,
  numbers     = left,
  columns     = fixed,
  keepspaces  = true,
  commentstyle = \slshape\color[RGB]{0,96,96},
  keywordstyle = \color[RGB]{40,40,255},
  basicstyle   = \ttfamily,
  rulesepcolor = \color{red!20!green!20!blue!20},
  numberstyle  = \color{darkgray},
  stringstyle  = \color[RGB]{128,0,0},
  % backgroundcolor = \color[RGB]{245,245,244},
  showstringspaces = false,
  morekeywords={alignas,continute,friend,register,true,alignof,decltype,goto,
    reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short,
    typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case,
    dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using,
    char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct,
    void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t,
    const,false,private,this,while,constexpr,float,protected,thread_local,
    const_cast,for,public,throw,std},
  emph={map,set,multimap,multiset,unordered_map,unordered_set,
    unordered_multiset,unordered_multimap,vector,string,list,deque,
    array,stack,forwared_list,iostream,memory,shared_ptr,unique_ptr,
    random,bitset,ostream,istream,cout,cin,endl,move,default_random_engine,
    uniform_int_distribution,iterator,algorithm,functional,bing,numeric,},
  emphstyle=\color{CPPViolet},
}

% 作图
\usepackage{tikz}
\usetikzlibrary{graphs, positioning, quotes, shapes.geometric}

% 首行缩进
\usepackage{indentfirst}
\setlength{\parindent}{2em}

\usepackage{float}
\usepackage{diagbox}
\usepackage{setspace}
\usepackage{zhnumber}
\usepackage{titlesec}

% \renewcommand\thechapter{\zhnum{chapter}}
% \renewcommand\thesection{\arabic{section}}

\titleformat{\chapter}{\centering\Huge\bfseries}{第\,\thechapter\,章}{1em}{}
% \titleformat{\section}{\raggedright\Large\bfseries}{\thesection\,}{1em}{}
% \titleformat{\subsection}{\raggedright\large\bfseries}{\,\thesubsection\,}{1em}{}
% \titleformat{\subsubsection}{\raggedright\large\bfseries}{\,\thesubsubsection\,}{1em}{}

\graphicspath{{figures/}}
\bibliographystyle{plainnat}

\pagestyle{fancy}
\fancyhead[L]{\song\xiaowu[0]{1180100217~郭炼}}
\fancyhead[C]{\song\xiaowu[0]{数据库实验三报告}}
\fancyhead[R]{\song\xiaowu[0]{哈尔滨工业大学}}
\fancyfoot[C]{\xiaowu-~\thepage~-}
\makeatletter
\def\headrule{{%
    \if@fancyplain\let\headrulewidth\plainheadrulewidth\fi
    \vskip2pt
    \hrule\@height2pt\@width\headwidth\vskip1pt
    \hrule\@height\headrulewidth\@width\headwidth\vskip-\headrulewidth\vskip-4pt
  }}
\makeatother

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[L]{\song\xiaowu[0]{1180100217~郭炼}}
  \fancyhead[C]{\song\xiaowu[0]{数据库实验三报告}}
  \fancyhead[R]{\song\xiaowu[0]{哈尔滨工业大学}}
  \fancyfoot[C]{\xiaowu-~\thepage~-}
}

\renewcommand{\today}{\number\year{年}\number\month{月}\number\day{日}}
\renewcommand{\contentsname}{\centering \hei{目录}}
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}
\renewcommand{\lstlistingname}{代码}
\numberwithin{figure}{chapter}
\numberwithin{table}{chapter}
\numberwithin{lstlisting}{chapter}

\renewcommand{\baselinestretch}{1.25}
\newcommand{\M}[1]{\mathbf{#1}}
\setcounter{secnumdepth}{4}

\begin{document}

\begin{titlepage}
  \vspace{5\baselineskip}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{figures/school.eps}
  \end{figure}

  \centering\hei{}

  \xiaosan\vspace{\baselineskip}

  \makebox[150bp][s]{数据库实验三报告}

  \erhao\vspace{2\baselineskip}

  \makebox[300bp][s]{实验三：查询执行器}

  \sanhao\vspace{3\baselineskip}

  \makebox[80bp][s]{姓名}~~\underline{\makebox[160bp][s]{郭炼}} \\ [24pt]
  \makebox[80bp][s]{学号}~~\underline{\makebox[160bp][s]{1 1 8 0 1 0 0 2 1 7}} \\ [24pt]
  \makebox[80bp][s]{老师}~~\underline{\makebox[160bp][s]{邹兆年}} \\ [24pt]
  \makebox[80bp][s]{专业}~~\underline{\makebox[160bp][s]{数据科学与大数据技术}} \\ [24pt]
  \makebox[80bp][s]{日期}~~\underline{\makebox[160bp][s]{2020 年 05 月 25 日}} \\ [24pt]
\end{titlepage}

\clearpage
\tableofcontents
\clearpage

\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\chapter{实验目的}
在实验二实现的 BadgerDB 缓冲池管理器的基础上，
本次实验继续实现 BadgerDB 的查询执行器，具体完成以下内容：
\begin{itemize}[fullwidth,itemindent=\parindent]
\item
  实现自然连接操作算法，
  对两个关系进行自然连接，
  具体实现基于块的嵌套循环连接算法。
\end{itemize}

\chapter{连接算法}
在本次实验中，
我们需要使用基于块的嵌套循环连接算法
来实现对两个关系的自然连接。

基于块的嵌套循环连接算法
就是一种朴素的暴力枚举算法。
该算法会
将两个关系中较小的关系（外关系）成批的读入内存中，
之后将较大的关系（内关系）依次读入内存中。
枚举两个块中的所有元组，之后尝试进行自然连接。
如果连接成功，就将其插入到结果关系中。
其如伪代码\ref{algo:block}所示。

\begin{algorithm}
  \caption{基于块的嵌套循环连接算法\label{algo:block}}
  \KwIn{两个待连接的关系 $S$ 和 $R$，可使用的缓冲块数目 $M$}
  \KwOut{$S$ 和 $R$ 自然连接的结果}

  \If{$B(S) > B(R)$} {
    交换 $S$ 和 $R$
  }
  \For{外关系 $S$ 中的每 $M - 1$ 块} {
    将这 $M - 1$ 块读入缓冲块 \\
    用内存查找结构来组织 $M - 1$ 块中的元组 \\
    \For{内关系 $R$ 中的每一块 $P$} {
      将 $P$ 读入缓冲区
      \For{$P$ 中的每个元组 $r$} {
        \For{内存查找结构中能与 $r$ 进行的元组 $s$} {
          连接 $r$ 和 $s$，将结果写入输出缓冲区
        }
      }
    }
  }

\end{algorithm}

\chapter{代码实现}
我们只需要编辑 executor.cpp 文件，
实现 \lstinline|NestedLoopJoinOperator| 类的
\lstinline|NestedLoopJoinOperator::execute| 方法就可以完成本次实验。

\section{tableSize 函数}
我首先实现了一个 \lstinline|tableSize| 函数，
用于统计一个关系块的数目。
该函数会遍历关系的所有块，用于统计数目。

该函数用于后续判断关系大小，
确定外关系 $S$ 和内关系 $R$。

\section{parseTuple 函数}
在本次实验中，元组是经过序列化的，
所有的值均是以二进制字节码的方式存储的。
为了便于后续的连接，
我们需要实现一个函数通过关系的模式来将
一个二进制码解析为一个二进制列表（\lstinline|vector<string>|）来便于访问。

该函数仿照 \lstinline|TableScanner| 的 \lstinline|print| 方法，
按照三种属性值来实现对二进制码的切片，
将对应的部分存储在一个线性表中。
这样就可以通过下标实现 $O(1)$ 的查找。

\begin{lstlisting}[caption=parseTuple 函数,
  basicstyle=\footnotesize\ttfamily,
  numberstyle=\footnotesize\color{darkgray}]
static void parseTuple(const TableSchema &tableSchema, const string &key, vector<string> &tuple) {
  tuple.clear();
  tuple.reserve(tableSchema.getAttrCount());
  for (int i = 0, current_index = 0; i < tableSchema.getAttrCount(); ++i) {
    switch (tableSchema.getAttrType(i)) {
    case INT: {
      tuple.push_back(string(key, current_index, 4));
      current_index += 4;
      break;
    }
    case CHAR: {
      int max_len = tableSchema.getAttrMaxSize(i), last = current_index;
      current_index += max_len;
      current_index += (4 - (max_len % 4)) % 4;
      tuple.push_back(string(key, last, current_index - last));
      break;
    }
    case VARCHAR: {
      int actual_len = key[current_index], last = current_index;
      current_index++;
      current_index += actual_len;
      current_index +=
          (4 - ((actual_len + 1) % 4)) % 4;
      tuple.push_back(string(key, last, current_index - last));
      break;
    }
    }
  }
}
\end{lstlisting}

\section{NestedLoopJoinOperator::execute 方法}
在本方法中，我们需要实现基于块的嵌套循环自然连接算法，
大体上就是将伪代码\ref{algo:block}转换为 C++ 代码。

我们使用
\lstinline|tableSize| 比较两个块的大小，判断外关系和内关系；
\lstinline|parseTuple| 将二进制码解析成二进制序列，便于后续比较；
用一个数组存储 $M - 1$ 块缓存对应的页的指针。
之后根据结果的模式，来进行连接。
对应结果模式的每一个属性：
\begin{itemize}[fullwidth,itemindent=\parindent]
\item
  如果 $S$ 和 $R$ 均含有该属性，那么判断其是否相等。
  如果不相等，则终止连接，否则连接到结果元组的二进制码中。
\item
  如果只有 $S$ 或 $R$ 均含有该属性，那么
  直接将该属性对应值连接到结果元组的二进制码中。
\item
  如果 $S$ 和 $R$ 均不含有该属性，那么报错。
\end{itemize}

如果连接成功，那么利用 \lstinline|HeapFileManager| 的
\lstinline|insertTuple| 方法将结果元组插入堆中。

需要注意的是， $B(S)$ 可以大于 $M - 1$，
所以可能需要多次读入 $S$ 关系的块。
此外每次读完对应的块后需要及时释放对应的缓冲块，
防止缓冲池中块的数目不足。

\chapter{实验总结}
在本次实验中，我
加深了对于基于块的嵌套循环连接算法的理解，
初步了解了二进制序列的存储元组的具体方式。
通过一些代码了解了
获取关系中的属性、
元组的内部表示方法、
元组在文件中的存储方式
的具体细节。

\end{document}
